	@Override
	public List<String> process(String input) throws BusinessException {
		List<String> tokens = new ArrayList<String>();
		StringBuilder sb = new StringBuilder();

		char[] arr = input.toCharArray();
		for (int i = 0; i < arr.length; i++) {

			char prior = (i - 1 > 0) ? arr[i - 1] : ' ';
			char current = arr[i];
			char next = (i + 1 < arr.length) ? arr[i + 1] : ' ';

			// extract acronyms
			// this will actually extract acronyms of any length
			// once it detects this pattern a.b.c 
			// it's a greedy lexer that breaks at ' '
			if (CodeUtilities.isAlpha(current) && '.' == next) {

				// Pattern-1	= U.S.A 	(5 chars)
				// Pattern-2	= U.S.A. 	(6 chars)
				if (i + 5 < input.length()) {

					// Pattern-1
					if (CodeUtilities.isAlpha(arr[i]) 
						&& '.' == arr[i + 1] 
						&& CodeUtilities.isAlpha(arr[i + 2]) 
						&& '.' == arr[i + 3] 
						&& CodeUtilities.isAlpha(arr[i + 4])) {

						for (; i < arr.length && arr[i] != ' '; i++) {
							sb.append(arr[i]);
						}

						// check for Pattern-2 (trailing '.')
						if (i + 1 < input.length() 
							&& '.' == arr[i + 1]) {
							sb.append(arr[i++]);
						}

						addToken(tokens, sb);
						sb = new StringBuilder();
						continue;
					}
				}
			}

			if ('w' == current && '/' == next) {
				sb.append(current);
				sb.append(next);
				addToken(tokens, sb);
				sb = new StringBuilder();
				i += 1;
				continue;
			}

			// extract URLs
			if ('h' == current && 't' == next) {
				if (i + 7 < input.length() && 				
					"http://".equals(input.substring(i, i + 7))) {

					for (; i < arr.length && arr[i] != ' '; i++) {
						sb.append(arr[i]);
					}

					addToken(tokens, sb);
					sb = new StringBuilder();
					continue;
				}
			}

			// extract windows drive letter paths
			// c:/ or c:\
			if (CodeUtilities.isAlpha(current) && ':' == next) {
				if (i + 2 < input.length() 
					&& (arr[i + 2] == '\\' 
					|| arr[i + 2] == '/')) {
					sb.append(current);
					sb.append(next);
					sb.append(arr[i + 2]);
					i += 2;
					continue;
				}
			}

			// keep numbers together when separated by a period
			// "4.0" should not be tokenized as { "4", ".", "0" }
			if (CodeUtilities.isNumber(current) && '.' == next) {
				if (i + 2 < input.length() && 
					CodeUtilities.isNumber(arr[i + 2])) {
					sb.append(current);
					sb.append(next);
					sb.append(arr[i + 2]);
					i += 2;
					continue;
				}
			}

			// keep alpha characters separated by hyphens together
			// "b-node" should not be tokenized as { "b", "-", "node" }
			if (CodeUtilities.isAlpha(current) && '-' == next) {
				if (i + 2 < input.length() && 
					CodeUtilities.isAlpha(arr[i + 2])) {
					sb.append(current);
					sb.append(next);
					sb.append(arr[i + 2]);
					i += 2;
					continue;
				}
			}

			// TODO: need a greedy look-ahead to 
			// avoid splitting this into multiple tokens 
			// "redbook@vnet.ibm.com" currently is 
			// tokenized as { "redbook@vnet", ".", "ibm", ".", "com" }
			// need to greedily lex all tokens up to the space
			// once the space is found, see if the last 4 chars are '.com' 
			// if so, then take the entire segment as a single token
			// don't separate tokens concatenated with an underscore
			// eg. "ws_srv01" is a single token, not { "ws", "_", "srv01" }
			if (CodeUtilities.isAlpha(current) && '_' == next) {
				if (i + 2 < input.length() && 
					CodeUtilities.isAlpha(arr[i + 2])) {
					sb.append(current);
					sb.append(next);
					i++;
					continue;
				}
			}

			// extract twitter channels
			if (('#' == current || 
				'@' == current) && 
				' ' != next && 
				!CodeUtilities.isSpecial(next)) {
				sb.append(current);
				continue;
			}

			// keep tokens like tcp/ip and os/2 and system/z together
			if (' ' != current && '/' == next) {
				sb.append(current);
				sb.append(next);
				i++;
				continue;
			}

			if (' ' == current) {
				addToken(tokens, sb);
				sb = new StringBuilder();
				continue;
			}

			// don't tokenize on <word>'s or <words>'
			// but do tokenize on '<words>
			if ('\'' == current) {
				if (' ' == prior) {
					addToken(tokens, "'");
				} else {
					sb.append(current);
				}

				continue;
			}

			if (CodeUtilities.isSpecial(current)) {
				addToken(tokens, sb);
				addToken(tokens, String.valueOf(current));
				sb = new StringBuilder();
				continue;
			}

			sb.append(current);
		}

		if (0 != sb.length()) {
			addToken(tokens, sb);
		}

		return tokens;
	}
